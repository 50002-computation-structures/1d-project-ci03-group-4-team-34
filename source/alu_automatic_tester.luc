module alu_automatic_tester#(
    CLK_FREQ ~ 1000 : CLK_FREQ > 0) 
(
    input clk,  // clock
    input rst,  // reset
    input io_button[5],
    input io_dip[3][8],
    output io_led[3][8],
    output io_segment[8],
    output io_select[4]
) {
     const SEVEN_SEG_DIV = $is_sim() ? 3 : 16
    const TEST_DELAY = CLK_FREQ * 3; // 3 second delay
    .clk(clk) {
     
        edge_detector io_button_edge[5](#RISE(5x{{1}}), #FALL(5x{{0}}))
        button_conditioner io_button_cond[5](#CLK_FREQ(5x{{$resize(CLK_FREQ, $width(10000000))}})) 
        .rst(rst) {
            
            multi_seven_seg seg(#DIV(SEVEN_SEG_DIV)) 
            dff delay_counter[$clog2(TEST_DELAY)];     
        }
    }
    
    alu alu;
    
    // Test case structure
    struct test_case {
        a[32],
        b[32],
        alufn[6],
        expected[32]
    }
    
    // Hardcoded test cases 
    const NUM_TEST_CASES = 5; // Can't seem to do $width(TEST_CASES) so this is a hacky workaround
    const TEST_CASES = {
        <test_case>(.a(32h00000000), .b(32h00000000), .alufn(6b000000), .expected(32h00000000)), // ADD
        <test_case>(.a(32hFFFFFFFF), .b(32h00000001), .alufn(6b000000), .expected(32h00000000)),  // ADD overflow
        <test_case>(.a(32h00000005), .b(32h00000003), .alufn(6b000001), .expected(32h00000002)), // SUB
        <test_case>(.a(32h000000FF), .b(32h0000000F), .alufn(6b011000), .expected(32h0000000F)), // AND
        <test_case>(.a(32h000000F0), .b(32h0000000F), .alufn(6b011110), .expected(32h000000FF))  // OR
    };
    
    enum States{
        IDLE,
        RUN, 
        CHECK
        }
    
    // Store states in DFFs
    dff tester_state[3](#INIT(States.IDLE),.clk(clk));
    dff a_temp[32](.clk(clk), .rst(rst));
    dff b_temp[32](.clk(clk), .rst(rst));
    dff alufn[6](.clk(clk), .rst(rst));
    dff test_id[8](.clk(clk), .rst(rst));
    
    bin_to_dec decimal_renderer(#DIGITS(4), #LEADING_ZEROS(1))
    always {        
        // condition the io buttons, then take **rising** edges only
        io_button_cond.in = io_button
        io_button_edge.in = io_button_cond.out
              
        // Connect inputs to ALU 
        alu.a = a_temp.q; 
        alu.b = b_temp.q;
        alu.alufn = alufn.q 
        
        // Reset LEDs
        io_led = 3x{ {8h00} }        
        
        // Update the state on each cycle
        tester_state.d = tester_state.q
        delay_counter.d = delay_counter.q + 1;
        
        case (tester_state.q) {
            // Default state where it does nothing. Moves to load state when button is pressed.
            States.IDLE: 
                if (io_button_edge.out[1]) {
                    tester_state.d = States.RUN
                    test_id.d = 0;
                    delay_counter.d = 0;
                } 
            States.RUN: 
                // Load test case from ROM
                a_temp.d = TEST_CASES[test_id.q].a;
                b_temp.d = TEST_CASES[test_id.q].b;
                alufn.d = TEST_CASES[test_id.q].alufn;
                
                // Stay in RUN state for test_delay
                if (delay_counter.q == TEST_DELAY - 1) {
                    tester_state.d = States.CHECK;
                    delay_counter.d = 0;
                } else {
                    delay_counter.d = delay_counter.q + 1;
                }
                
            States.CHECK:
                // Compare ALU output with expected value
                if (alu.out == TEST_CASES[test_id.q].expected) {
                    io_led[1][7:0] = 8b11111111;  // Correct is on the right side
                } else {
                    io_led[2][7:0] =  8b11111111;  // Incorrect is on the left sie
                }
                // Check if delay period has elapsed
                if (delay_counter.q == TEST_DELAY - 1) {
                    // Move to next test case or return to IDLE
                    test_id.d = test_id.q + 1;
                    if (test_id.q + 1 < NUM_TEST_CASES) {
                        tester_state.d = States.RUN;
                    } else {
                        tester_state.d = States.IDLE;
                    }
                    delay_counter.d = 0;  // Reset counter for next use
                }
        }

        // 7-segment display shows test ID
        decimal_renderer.value = tester_state.q * 1000 + test_id.q;  // Format: S:0-2 T:000-999
        seg.values = decimal_renderer.digits
        io_segment = ~seg.seg
        io_select = ~seg.sel
    }
}