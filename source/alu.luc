module alu (
    input a[32],
    input b[32],
    input alufn[6],
    output out[32],
    output z,
    output v,
    output n
) {
    // Instantiating submodules
    adder adder(#SIZE(32));
    compare compare();
    boolean boolean(#SIZE(32));
    shifter shifter();
    multiplier multiplier();
    divider divider();
    modulus modulus();
    cmpmt cmpmt();
    


    always {
        // Adder logic
        adder.a = a;
        adder.b = b;
        adder.alufn_signal = alufn;
        z = adder.z;
        v = adder.v;
        n = adder.n;
        
        // Compare logic
        compare.z = adder.z
        compare.v = adder.v
        compare.n = adder.n
        compare.alufn = alufn

        // Boolean logic
        boolean.a = a
        boolean.b = b 
        boolean.alufn = alufn
        
        // Shifter logic
        shifter.a = a
        shifter.b = b
        shifter.alufn = alufn
        
        // Multiplier logic
        multiplier.a = a
        multiplier.b = b
        
        // Divider Logic
        divider.a = a
        divider.b = b
        
        //modulus logic
        modulus.a = a
        modulus.b = b
        
        //cmpmt logic
        cmpmt.a = a;
        cmpmt.alufn = alufn[0];
        
        // ALU output logic based on ALUFN[5:4]
        if (alufn[5:4] == 2b00) {
            if (alufn[1:0] == 2b10) {
                out = multiplier.mul;
            } else if (alufn[1:0] == 2b11) {
                out = divider.d;
            } else {
                out = adder.out;
            } 
        } else if (alufn[5:4] == 2b11) {
            out = c{31x{b0}, compare.cmp};  // Concatenate compare result to 32 bits
        } else if (alufn[5:4] == 2b01) {
            if (alufn[3:0] == 4b0100) {  // Bitwise NOT (~a) 
                out = cmpmt.m;
            } else if (alufn[3:0] == 4b0101) {  // Twoâ€™s Complement (-a)
                out = cmpmt.m;
            } else {
                out = boolean.bool; // Other Boolean Operations
            }
        } else if (alufn[5:4] == 2b10) {
            out = shifter.shift;
        }else if (alufn == 6b000111) { 
            out = ~(a & b); //NAND IS DONE HERE
        } else if (alufn[1:0] == 2b01) {
                out = modulus.m; 
        } else {
            // Default case (optional)
            out = 32b0;  // Default to zero if no valid ALUFN[5:4] match
        }
    }
}